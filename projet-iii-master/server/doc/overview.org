#+AUTHOR: Olivier Dion
#+MACRO: program bixi-server
#+OPTIONS: ^:nil

* {{{program}}}

  The {{{program}}} is a RESTful server.  It communicates with clients
  using HTTP version 1.1.  Other versions are not supported and the
  server will not accept downgrade or upgrade of the version of the
  protocol during the exchange with the clients.  The server will
  listen on the port given by the command line argument *-port*, or on
  the port *443* by default.  The latter might requires
  *CAP_NET_BIND_SERVICE* in some cases.  Contact your system
  administrator for more informations on that subject.

** SSL/TLS

   {{{program}}} will by default do its communications over encrypted
   channels using *TLS*.  For developpement, the root authorithy under
   ../certs/* can be trusted to accept the localhost certificate that
   is auto-signed.

** Execution model

   When the server starts, it first parse the command line option
   using the utility *opt* in the *utils* module.  It then proceed to set
   some signal handlers, mainly for *SIGTERM* in order to correctly
   shutdown.  After that, the server initializes the *OpenSSL* library
   and create a context for the encryption using the localhost,
   self-signed, certificate.  It then proceed to bind a passive socket
   to a loopback address (useful for local debugging).  If the option
   *-no-loop* is passed, then the server will bind to any address
   available, thus it will be accessible on the *LAN*.  Finally, the
   server listens and accepts incomming connections on this socket.

   Here's a graph representing this model.

   #+BEGIN_SRC dot :file execution-model.png 
     digraph graph_name {
       graph [
	 charset = "UTF-8";
	 label = "Execution model",
	 labelloc = "t",
	 labeljust = "c",
	 bgcolor = "#343434",
	 fontcolor = white,
	 fontsize = 18,
	 style = "filled",
	 rankdir = TB,
	 margin = 0.2,
	 splines = spline,
	 ranksep = 1.0,
	 nodesep = 0.9
       ];

       node [
	 colorscheme = "rdylgn11"
	 style = "solid,filled",
	 fontsize = 16,
	 fontcolor = 6,
	 fontname = "Migu 1M",
	 color = 7,
	 fillcolor = 11,
	 height = 0.6,
	 width = 1.2
       ];

       edge [
	 style = solid,
	 fontsize = 14,
	 fontcolor = white,
	 fontname = "Migu 1M",
	 color = white,
	 labelfloat = true,
	 labeldistance = 2.5,
	 labelangle = 70
       ];

       // node define
       accept [label="accept(2)"];
       fork [label="fork(2)"];
       REST [label = "Handle REST"];
       request [label = "Receive request"];
       response [label = "Send response"];
       exit [label="_exit(2)"];
       start [shape=box, label="START"];

       start  -> server;
       server -> accept;
       accept -> fork;
       fork   -> parent;
       fork   -> child;

       parent -> server;
       server -> exit [label = "SIGTERM"];

       child    -> REST
       REST     -> request;
       request  -> response;
       response -> exit;
     }
   #+END_SRC

   #+RESULTS:
   [[file:execution-model.png]]

*** Connection multiplexer (parent)

   For every new connection, the server is forked and the parent close
   the connection, leaving the ownership of the connection to it
   child.  This strategy is used so that if something bad happen on
   this connection, for example a *SEGFAULT*, then only this connection
   will be closed and the server and all the other connectionsw will
   still be alive.

*** Client handler (child)

   The child that is serving a client then wrap the socket file
   descriptor into a C libc *FILE* object.  This is useful because it
   allows us to use the same interface for reading the socket, wether
   it's encrypted or not.  This can be see by the usage of
   *fopencookie()* on the socket when *TLS* is activated.  After the
   stream has been created, it is passed down to the *rest* utility in
   the *core* module.

** mk/

   This is part of the build system.  It's quite a hack around *make(1)*
   and there's no need to go into the details here.

** tools/
   
   Useful scripts to be used for the project can be put here.  
   
** core/

   This is the core of the project.  This currently only contain the
   main compilation unit and the *REST* handler.  You can see this
   module as the glue that stick the other modules together.

** utils/

   The *utils* module regroups utilities useful for other modules.

*** http

    The http uility allows to scan a HTTP v1.1 request and manipulate
    a corresponding *struct http_request*.  The scanner is generated by
    *flex(1)*.

*** json

    The json utility allows to parse a json string in order to create
    a json object.  Allows json types are supported.  This utility
    allows to recursively stream a json object to a C stream or even
    in *transfert-encoding: chunked* mode for http responses.  

    The parser is auto generated using *bison(1)*.

*** others

    Other utilites such as *btree* and *opt* are utilies that I imported
    from personnal project.  They have proven to be very useful.

** routes/

   This module is used to create new routes to the server.  See
   *routes/example.c* for a complete example on how to make a route.

** tests/

   This is the tests framework.  It runs several tests in parallel
   with and without *TLS*.  Tests are made by doing requests to the
   server with *curl(1)* or *netcat(1)*.  Coverage of the execution of the
   server is done by using *liggcov* built-in *GCC* and collected using
   *gcovr(1)*.  All results can be found under *test-results/*.
